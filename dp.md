# 다이나믹 프로그래밍
큰 문제를 작은 문제로 나누어서 푸는 알고리즘

## 목표
모든 문제를 중복 없이 한번만 푸는 것.

## 방식
### Top-Down
- 보통 재귀호출을 이용해서 푼다.
- N이 주어지면 N부터 가장 작은 값까지 내려가면서 푼다.
- 점화식을 이해하기가 더 쉽다.

### Bottom-Up
- 보통 반복문을 이용해서 푼다.
- 가장 작은 값부터 N까지 반복하면서 푼다.
- 재귀호출을 사용하지 않기 떄문에 시간복잡도 면에서 좋다.

## 점화식
- dp 문제를 풀 때는 제일 먼저 점화식을 작성해 보는 것이 좋다.
- 꼭 수식이 아니더라도 말로 풀어서 작성해본다.
- 점화식의 시간 복잡도는 문제 하나를 푸는 시간의 시간복잡도이다.

## 시간복잡도
전체 문제의 개수 x 문제 한개를 푸는 시간(점화식)

## 연속된 다이나믹 프로그래밍의 점화식
- 일단 이차원 배열을 이용한다는 것을 먼저 떠올리자.
- 또한 문제의 조건을 보고 예외처리를 진행해 주어야 한다.

## LIS(가장 긴 증가하는 부분 수열)
- 주어진 배열에서 가장 긴 증가하는 부분 수열을 찾는 문제를 LIS 라고 한다.
- 개수를 구하는 d 배열의 각 값을 1로 초기화 해주어야 한다.
- 그 이유는 수열이라는 건 각자의 값 하나도 수열이라고 할 수 있기 때문이다.
- i보다 작은 값부터 0까지 j를 순회하면서 a[i]보다 a[j]가 작은 경우는 LIS 라고 할 수 있다.
- 여기서 d[i]의 값과 d[j]+1의 값을 비교하여 더 큰 값으로 d[i]를 갱신해준다.
- d[j]+1봐 비교하는 이유는 기존 d[j]의 개수에서 현재 i 위치의 값을 포함해 주어야 하기 때문이다.
- 
